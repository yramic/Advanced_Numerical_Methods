#include <Eigen/Dense>
#include <cmath>
#include <iomanip>

#include "dirichlet.hpp"
#include "double_layer.hpp"
#include "parametrized_circular_arc.hpp"
#include "parametrized_fourier_sum.hpp"
#include "parametrized_mesh.hpp"
#include "single_layer.hpp"
#define _USE_MATH_DEFINES

int main() {
  std::cout << "Examples for Dirichlet BVP" << std::endl;
  std::cout << "##########################" << std::endl;
  // Gauss quadrature order
  unsigned order = 16;
  std::cout << "Gauss Quadrature used with order = " << order << std::endl;
  std::cout << std::setw(12) << "numpanels" << std::setw(16) << "DFK"
            << std::setw(16) << "DSK" << std::setw(16) << "IDFK"
            << std::setw(16) << "IDSK" << std::endl;
  std::cout << std::setw(12) << "         " << std::setw(16) << "Av "
            << std::setw(16) << "Av " << std::setw(16) << "pt. "
            << std::setw(16) << "pt. " << std::endl;
  std::cout << std::setw(12) << "#########" << std::setw(16) << "###"
            << std::setw(16) << "###" << std::setw(16) << "####"
            << std::setw(16) << "####" << std::endl;

  // Loop over number of panels
  for (unsigned numpanels = 5; numpanels < 201; numpanels += 5) {
    // Defining the boundary of domain using fourier sum parametrization
    // Coefficients for cosine terms
    Eigen::MatrixXd cos_list(2, 2);
    cos_list << 0.25, 0.1625, 0, 0;
    // Coefficients for sine terms
    Eigen::MatrixXd sin_list(2, 2);
    sin_list << 0, 0, 0.375, 0;
    // Cardioid domain
    // cos_list << 1., 0, 0, 0.5;
    // sin_list << 0, -0.5, 1., 0;
    // Parametrized curve for kite shaped boundary
    parametricbem2d::ParametrizedFourierSum curve(cos_list, sin_list, 0,
                                                  2 * M_PI);
    // parametricbem2d::ParametrizedCircularArc curve(Eigen::Vector2d
    // (0,0),1.,0,2*M_PI);

    // Making a ParametrizedMesh object
    parametricbem2d::ParametrizedMesh mesh(curve.split(numpanels));
    // Getting the panels
    using PanelVector = parametricbem2d::PanelVector;
    PanelVector panels = mesh.getPanels();

    // Point source location
    Eigen::Vector2d source_pt(2, 0);
    // Point source charge
    double q = 1.;

    // Lambda function for the potential generated by  the source charge
    // Can also be used for evaluating the dirichlet trace
    auto potential = [&](double x1, double x2) {
      Eigen::Vector2d x(x1, x2);  // Target point
      // Distance between source and target point
      double dist = (x - source_pt).norm();
      // Assertion required as potential not defined at x = source_pt
      assert(dist > 1e-9);
      return -1. / 2. / M_PI * log(dist) * q;
    };

    // Lambda function for evaluating the Neumann Trace
    auto Tn = [&](const parametricbem2d::AbstractParametrizedCurve &gamma) {
      // The evaluation point -> mid point of parameter interval
      double t = 0.;
      Eigen::Vector2d x = gamma.operator()(t);
      // Getting the tangent vector to evaluate normal
      Eigen::Vector2d tangent = gamma.Derivative(t);
      Eigen::Vector2d normal;
      // Outward normal vector assuming anticlockwise curve
      normal << tangent(1), -tangent(0);
      // Normalizing the normal vector
      normal /= normal.norm();
      double dotprod =
          (source_pt - x).dot(normal) / (source_pt - x).squaredNorm();
      // Neumann trace
      return 1. / 2. / M_PI * dotprod * q;
    };

    // Lambda function for evaluating the Neumann Trace
    auto Tn0 = [&](const parametricbem2d::AbstractParametrizedCurve &gamma) {
      // The evaluation point -> mid point of parameter interval
      double t = -1.;
      Eigen::Vector2d x = gamma.operator()(t);
      // Getting the tangent vector to evaluate normal
      Eigen::Vector2d tangent = gamma.Derivative(t);
      Eigen::Vector2d normal;
      // Outward normal vector assuming anticlockwise curve
      normal << tangent(1), -tangent(0);
      // Normalizing the normal vector
      normal /= normal.norm();
      double dotprod =
          (source_pt - x).dot(normal) / (source_pt - x).squaredNorm();
      // Neumann trace
      return 1. / 2. / M_PI * dotprod * q;
    };

    // Solving the Dirichlet Problem using direct first kind method
    // Getting the estimated Neumann Traces from the solver
    Eigen::VectorXd Tn_dfk =
        parametricbem2d::dirichlet_bvp::direct_first_kind::solve(
            mesh, potential, order);

    // Solving the Dirichlet Problem using direct first second method
    // Getting the estimated Neumann Traces from the solver
    Eigen::VectorXd dsk_sol =
        parametricbem2d::dirichlet_bvp::direct_second_kind::solve(
            mesh, potential, order);
    // Eigen::VectorXd Tn_dsk(numpanels);
    // for (unsigned i = 0 ; i < numpanels ; ++i) {
    //   Tn_dsk(i) = 0.5 * (dsk_sol(i) + dsk_sol((i+1)%numpanels) );
    // }
    Eigen::VectorXd Tn_dsk = 0.5 * dsk_sol.segment(0, numpanels);

    // Solving the Dirichlet Problem using indirect first kind method
    Eigen::VectorXd sol_idfk =
        parametricbem2d::dirichlet_bvp::indirect_first_kind::solve(
            mesh, potential, order);

    // Solving the Dirichlet Problem using indirect second kind method
    Eigen::VectorXd sol_idsk =
        parametricbem2d::dirichlet_bvp::indirect_second_kind::solve(
            mesh, potential, order);

    // Trial space used in direct first kind method
    parametricbem2d::DiscontinuousSpace<0> space;
    // Evaluating the V matrix for calculating av error norm
    Eigen::MatrixXd V =
        parametricbem2d::single_layer::GalerkinMatrix(mesh, space, order);

    // Evaluating exact Neumann Traces at mid point of parameter range
    Eigen::VectorXd Tn_ex(numpanels);
    for (unsigned i = 0; i < numpanels; ++i) Tn_ex(i) = Tn(*panels[i]);

    Eigen::VectorXd Tn_ex0(numpanels);
    for (unsigned i = 0; i < numpanels; ++i) Tn_ex0(i) = Tn0(*panels[i]);

    // Finding the solutions using cpp hilbert
    auto potentialcpp = [&](const Eigen::VectorXd &pt) {
      return potential(pt(0), pt(1));
    };

    // Evaluation point for indirect solutions
    Eigen::Vector2d eval_pt(0, 0);

    // Evaluating the errors
    // Direct First Kind
    double err_dfk = fabs(
        (Tn_ex - Tn_dfk).transpose().dot(V * (Tn_ex - Tn_dfk)));  // av norm
    // Direct Second Kind
    double err_dsk =
        // fabs((Tn_ex - Tn_dsk).transpose().dot(V * (Tn_ex - Tn_dsk))); // av
        // norm
        fabs((Tn_ex0 - Tn_dsk).transpose().dot((Tn_ex0 - Tn_dsk)));
    // Indirect First Kind, point error evaluation
    double err_idfk = fabs(potential(eval_pt(0), eval_pt(1)) -
                           parametricbem2d::single_layer::Potential(
                               eval_pt, sol_idfk, mesh, space, order));
    // Indirect Second Kind, point error evaluation
    double err_idsk = fabs(potential(eval_pt(0), eval_pt(1)) -
                           parametricbem2d::double_layer::Potential(
                               eval_pt, sol_idsk, mesh, space, order));

    std::cout << std::setw(12) << numpanels << std::setw(16) << err_dfk
              << std::setw(16) << err_dsk << std::setw(16) << err_idfk
              << std::setw(16) << err_idsk << std::endl;
    /*Eigen::VectorXd test(2*numpanels);
    for (unsigned j = 0 ; j < numpanels ; ++j) {
      // The evaluation point -> mid point of parameter interval
      Eigen::Vector2d x = panels[j]->operator()(-1);
      // Getting the tangent vector to evaluate normal
      Eigen::Vector2d tangent = panels[j]->Derivative(-1);
      Eigen::Vector2d normal;
      // Outward normal vector assuming anticlockwise curve
      normal << tangent(1), -tangent(0);
      // Normalizing the normal vector
      normal /= normal.norm();
      double dotprod =
          (source_pt - x).dot(normal) / (source_pt - x).squaredNorm();
      // Neumann trace
      test(j) = 1. / 2. / M_PI * dotprod * q;
      test(j+numpanels) = -test(j);
    }
    Eigen::VectorXd add(numpanels);
    add << test.segment(1,numpanels-1),test(0);
    Eigen::VectorXd addd(2*numpanels);
    addd << add,add;
    test += addd;
    parametricbem2d::DiscontinuousSpace<1> sapace;
    Eigen::MatrixXd wee = parametricbem2d::single_layer::GalerkinMatrix(mesh,
    sapace, order); std::cout << "wee arror: " <<
    (test-dsk_sol).transpose().dot(wee * (test-dsk_sol)) << std::endl;*/
  }
  return 0;
}
