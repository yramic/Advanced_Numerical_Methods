#include "1_9_a.cpp"
#include "BoundaryMesh.hpp"
#include "buildK.hpp"
#include "buildM.hpp"
#include "buildV.hpp"
#include "buildW.hpp"
#include "dirichlet.hpp"
#include "double_layer.hpp"
#include "parametrized_circular_arc.hpp"
#include "parametrized_fourier_sum.hpp"
#include "parametrized_mesh.hpp"
#include "single_layer.hpp"
#include <Eigen/Dense>
#include <cmath>
#include <iomanip>
#define _USE_MATH_DEFINES

int main() {
  std::cout << "Examples for Dirichlet BVP" << std::endl;
  std::cout << "##########################" << std::endl;
  // Gauss quadrature order
  unsigned order = 16;
  std::cout << "Gauss Quadrature used with order = " << order << std::endl;
  std::cout << std::setw(12) << "numpanels" << std::setw(16) << "DFK"
            << std::setw(16) << "DSK" << std::setw(16) << "IDFK"
            << std::setw(16) << "IDSK" << std::endl;
  std::cout << std::setw(12) << "         " << std::setw(16) << "Av "
            << std::setw(16) << "Av " << std::setw(16) << "pt. "
            << std::setw(16) << "pt. " << std::endl;
  std::cout << std::setw(12) << "#########" << std::setw(16) << "###"
            << std::setw(16) << "###" << std::setw(16) << "####"
            << std::setw(16) << "####" << std::endl;

  // Loop over number of panels
  for (unsigned numpanels = 5; numpanels < 201; numpanels += 10) {
    // Defining the boundary of domain using fourier sum parametrization
    // Coefficients for cosine terms
    Eigen::MatrixXd cos_list(2, 2);
    cos_list << 1., 0, 0, 0.5;
    // Coefficients for sine terms
    Eigen::MatrixXd sin_list(2, 2);
    sin_list << 0, -0.5, 1., 0;
    // Parametrized curve for heart shaped boundary
    parametricbem2d::ParametrizedFourierSum heart(cos_list, sin_list, 0,
                                                  2 * M_PI);

    // Making a ParametrizedMesh object
    parametricbem2d::ParametrizedMesh mesh(heart.split(numpanels));
    // Getting the panels
    using PanelVector = parametricbem2d::PanelVector;
    PanelVector panels = mesh.getPanels();

    // Point source location
    Eigen::Vector2d source_pt(2, 0);
    // Point source charge
    double q = 1.;

    // Lambda function for the potential generated by  the source charge
    // Can also be used for evaluating the dirichlet trace
    auto potential = [&](double x1, double x2) {
      Eigen::Vector2d x(x1, x2); // Target point
      // Distance between source and target point
      double dist = (x - source_pt).norm();
      // Assertion required as potential not defined at x = source_pt
      assert(dist > 1e-9);
      return -1. / 2. / M_PI * log(dist) * q;
    };

    // Lambda function for evaluating the Neumann Trace
    auto Tn = [&](const parametricbem2d::AbstractParametrizedCurve &gamma) {
      // The evaluation point -> mid point of parameter interval
      double t = 0.;
      Eigen::Vector2d x = gamma.operator()(t);
      // Getting the tangent vector to evaluate normal
      Eigen::Vector2d tangent = gamma.Derivative(t);
      Eigen::Vector2d normal;
      // Outward normal vector assuming anticlockwise curve
      normal << tangent(1), -tangent(0);
      // Normalizing the normal vector
      normal /= normal.norm();
      double dotprod =
          (source_pt - x).dot(normal) / (source_pt - x).squaredNorm();
      // Neumann trace
      return 1. / 2. / M_PI * dotprod * q;
    };

    // Solving the Dirichlet Problem using direct first kind method
    // Getting the estimated Neumann Traces from the solver
    Eigen::VectorXd Tn_dfk =
        parametricbem2d::dirichlet_bvp::direct_first_kind::solve(
            mesh, potential, order);

    // Solving the Dirichlet Problem using direct first second method
    // Getting the estimated Neumann Traces from the solver
    Eigen::VectorXd Tn_dsk =
        parametricbem2d::dirichlet_bvp::direct_second_kind::solve(
            mesh, potential, order);

    // Solving the Dirichlet Problem using indirect first kind method
    Eigen::VectorXd sol_idfk =
        parametricbem2d::dirichlet_bvp::indirect_first_kind::solve(
            mesh, potential, order);

    // Solving the Dirichlet Problem using indirect second kind method
    Eigen::VectorXd sol_idsk =
        parametricbem2d::dirichlet_bvp::indirect_second_kind::solve(
            mesh, potential, order);

    // Trial space used in direct first kind method
    parametricbem2d::DiscontinuousSpace<0> space;
    // Evaluating the V matrix for calculating av error norm
    Eigen::MatrixXd V =
        parametricbem2d::single_layer::GalerkinMatrix(mesh, space, order);

    // Evaluating exact Neumann Traces at mid point of parameter range
    Eigen::VectorXd Tn_ex(numpanels);
    for (unsigned i = 0; i < numpanels; ++i)
      Tn_ex(i) = Tn(*panels[i]);

    // Finding the solutions using cpp hilbert
    auto potentialcpp = [&](const VectorXd &pt) {
      return potential(pt(0), pt(1));
    };

    // Evaluation point for indirect solutions
    Eigen::Vector2d eval_pt(0, 0);

    BoundaryMesh bmesh = createMeshwithGamma(heart, numpanels);
    bool debug = false;
    if (debug) {
      // Getting parametricbem galerkin matrices
      // Same trial and test spaces
      parametricbem2d::DiscontinuousSpace<0> trial_space;
      parametricbem2d::DiscontinuousSpace<0> test_space;
      // Space used for interpolation of Dirichlet data
      parametricbem2d::ContinuousSpace<1> g_interpol_space;
      // Computing V matrix
      Eigen::MatrixXd V = parametricbem2d::single_layer::GalerkinMatrix(
          mesh, trial_space, order);
      // Computing mass matrix
      Eigen::MatrixXd M = parametricbem2d::MassMatrix(mesh, test_space,
                                                      g_interpol_space, order);

      // Getting Cpp Hilbert Galerkin matrices
      std::cout << "Debugging Dirichlet indirect first kind method; numpanels: "
                << numpanels << std::endl;
      Eigen::MatrixXd Vcpp;
      double eta = 0;
      BoundaryMesh bmesh = createMeshwithGamma(heart, numpanels);
      computeV(Vcpp, bmesh, eta);
      Eigen::SparseMatrix<double> M01(bmesh.numElements(), bmesh.numElements());
      computeM01(M01, bmesh);
      Eigen::MatrixXd Mcpp(M01);

      // Evaluating errors for Galerkin matrices
      std::cout << "V error: " << (V - Vcpp).norm() << std::endl;
      std::cout << "M error: " << (M - Mcpp).norm() << std::endl;

      Eigen::VectorXd g_N(numpanels);
      for (unsigned i = 0; i < numpanels; ++i) {
        Eigen::Vector2d pt = mesh.getVertex(i);
        g_N(i) = potential(pt(0), pt(1));
      }

      int N = bmesh.numVertices();
      Eigen::VectorXd gNcoeff(N);
      for (int i = 0; i < N; ++i)
        gNcoeff(i) = potentialcpp(bmesh.getVertex(i));
      std::cout << "Dirichlet data eroor: " << (gNcoeff - g_N).norm()
                << std::endl;
      // solution from cpp hilbert
      Eigen::VectorXd sol_idfk_cpp = Vcpp.lu().solve(Mcpp * gNcoeff);
      std::cout << "sol_idfk error: " << (sol_idfk - sol_idfk_cpp).norm()
                << std::endl;
      std::cout << "sol_idfk:" << std::endl << sol_idfk << std::endl;
      std::cout << "sol_idfk_cpp:" << std::endl << sol_idfk_cpp << std::endl;
      Eigen::VectorXd SLphi_x(1);
      evaluateV(SLphi_x, bmesh, sol_idfk_cpp, eval_pt.transpose(), eta);
      double u_idfk = parametricbem2d::single_layer::Potential(
          eval_pt, sol_idfk, mesh, space, order);
      std::cout << "potential diff idfk: " << fabs(u_idfk - SLphi_x(0))
                << std::endl;
    }

    // Evaluating the errors
    // Direct First Kind
    double err_dfk =
        fabs((Tn_ex - Tn_dfk).transpose().dot(V * (Tn_ex - Tn_dfk))); // av norm
    // Direct Second Kind
    double err_dsk =
        fabs((Tn_ex - Tn_dsk).transpose().dot(V * (Tn_ex - Tn_dsk))); // av norm
    // Indirect First Kind, point error evaluation
    double err_idfk = fabs(potential(eval_pt(0), eval_pt(1)) -
                           parametricbem2d::single_layer::Potential(
                               eval_pt, sol_idfk, mesh, space, order));
    // Indirect Second Kind, point error evaluation
    double err_idsk = fabs(potential(eval_pt(0), eval_pt(1)) -
                           parametricbem2d::double_layer::Potential(
                               eval_pt, sol_idsk, mesh, space, order));

    std::cout << std::setw(12) << numpanels << std::setw(16) << err_dfk
              << std::setw(16) << err_dsk << std::setw(16) << err_idfk
              << std::setw(16) << err_idsk << std::endl;
  }
  return 0;
}
