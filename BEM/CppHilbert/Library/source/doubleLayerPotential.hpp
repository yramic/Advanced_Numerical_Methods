///////////////////////////////////////////////////////////////////////////////
/// \file doubleLayerPotential.hpp
/// \brief This file provides functions to compute the Galerkin Matrix K given
///  by
///  \f[ K_{ij} = -\frac{1}{2\pi}\int_{Ei} \int_{supp \phi_j}\frac{<y-x,n>}{
///                |y-x|^2} \phi_j(y)ds_y ds_x \f]
///
///  This file is part of the HILBERT program package for the numerical
///  solution of the Laplace equation with mixed boundary conditions by use of
///  BEM in 2D.
///
///  C++ adaptation for ANCSE17 of HILBERT V3.1 TUWien 2009-2013
///////////////////////////////////////////////////////////////////////////////
#ifndef _DOUBLELAYERPOTENTIAL_HPP_GUARD
#define _DOUBLELAYERPOTENTIAL_HPP_GUARD

#include "geometry.hpp"

/**
 *  Computes the double-layer potential type integral
 *  \f[   G(k,p,q) = \int_{-1}^1 t^k/|tp+q|^2 dt   \f]
 *
 *  by use of its antiderivative.
 *
 *  @param[in] k    Power of t
 *  @param[in] p,q  2d-vectors generated by direction vectors of the panels
 * Ei,Ej
 *  @return Result of the integral \f$ \int_{-1}^1 t^k/|tp+q|^2 dt \f$
 */
double dlp(int k, const Eigen::Vector2d& p, const Eigen::Vector2d& q);

/**
 *  This function computes one entry of the matrix K. It decides whether semi
 *  analytic or analytic computation should be chosen via the criterion:
 *  \f[ dist(Ei, Ej) \eta >= \min(diam(Ei), diam(Ej)) \f]
 *
 *  FALSE resp. \f$\eta=0\f$: compute analytically
 *
 *  TRUE: compute semi analytically
 *
 *  It furthermore ensures that the outer interval Ei is smaller than the inner
 *  one Ej. If this is not the case computeKijSwappedSemianalytic() is called.
 *
 *  \f[ I0 = const\int_{-1}^1\int_{-1}^1 f(s,t) dtds  \f]
 *  \f[ I1 = const\int_{-1}^1\int_{-1}^1 f(s,t)t dtds \f]
 *  with: \f$const = -\frac{1}{2\pi}\frac{|Ei|}{2}\frac{|Ej|}{2}\f$ and
 *  \f$ f(s,t)=<su+tv+w,n>/|su+tv+w|^2 \f$
 *
 *  All types of computation use dlp() to compute \f$I0,I1\f$, which are
 * computed in computeKijAnalytic() or computeKijSemianalytic() and assembled to
 * one Kij-Entry in computeK().
 *
 *  @param[out] I0,I1  Pointers to the 2 summands I0,I1 which are needed for
 *                     assembling one K_ij-Entry
 *  @param[in] eta     Admissibility constant greater or equal to 0
 *  @param[in] a,b,c,d  2d vectors with the coordinates of these points
 */
void computeKij(double* I0, double* I1, double eta, const Eigen::Vector2d& a,
                const Eigen::Vector2d& b, const Eigen::Vector2d& c,
                const Eigen::Vector2d& d);

/**
 *  Analytic computation of K_ij by use of antiderivatives. I0 and I1 are solved
 *  with dlp(), whereas u=a-b, v=d-c and w=c+d-(a+b).
 *
 *  @param[out] I0,I1  Pointers to the 2 summands I0,I1 which are needed for
 *                     assembling one K_ij-Entry
 *  @param[in] a,b,c,d  2d vectors with the coordinates of these points
 */
void computeKijAnalytic(double* I0, double* I1, const Eigen::Vector2d& a,
                        const Eigen::Vector2d& b, const Eigen::Vector2d& c,
                        const Eigen::Vector2d& d);

/**
 *  Computes the entry K_ij similar to computeKijAnalytic(), but the integration
 *  order is swapped, i.e. u=d-c, v=a-b and  w=c+d-(a+b).
 *
 *  @param[out] I0,I1  Pointers to the 2 summands I0,I1 which are needed for
 *                     assembling one K_ij-Entry
 *  @param[in] a,b,c,d  2d vectors with the coordinates of these points
 */
void computeKijSwappedAnalytic(double* I0, double* I1, const Eigen::Vector2d& a,
                               const Eigen::Vector2d& b,
                               const Eigen::Vector2d& c,
                               const Eigen::Vector2d& d);

/**
 *  The entries of the K-matrix are calculated semi analytic.
 *  The outer integration (Ei) is approximated with 16-point Gaussian quadrature
 *  and the inner one (Ej) is computed analytically, i.e. u=a-b, v=d-c and
 *   w=c+d-(a+b).
 *
 *  @param[out] I0,I1  Pointers to the 2 summands I0,I1 which are needed for
 *                     assembling one K_ij-Entry
 *  @param[in] a,b,c,d  2d vectors with the coordinates of these points
 */
void computeKijSemianalytic(double* I0, double* I1, const Eigen::Vector2d& a,
                            const Eigen::Vector2d& b, const Eigen::Vector2d& c,
                            const Eigen::Vector2d& d);

/**
 *  Computes the K_ij-Entry similar to computeKijSemianalytic(), but the
 *  integration order is swapped,i.e. u=d-c, v=a-b and w=c+d-(a+b).
 *
 *  @param[out] I0,I1  Pointers to the 2 summands I0,I1 which are needed for
 *                     assembling one K_ij-Entry
 *  @param[in] a,b,c,d  2d vectors with the coordinates of these points
 */
void computeKijSwappedSemianalytic(double* I0, double* I1,
                                   const Eigen::Vector2d& a,
                                   const Eigen::Vector2d& b,
                                   const Eigen::Vector2d& c,
                                   const Eigen::Vector2d& d);

#endif
