///////////////////////////////////////////////////////////////////////////////
/// \file doubleLayerPotential.hpp
/// \brief This file provides functions to compute the Galerkin Matrix K given
///  by
///  \f[ K_{ij} = -\frac{1}{2\pi}\int_{Ei} \int_{supp \phi_j}\frac{<y-x,n>}{
///                |y-x|^2} \phi_j(y)ds_y ds_x \f]
///
///  This file is part of the HILBERT program package for the numerical
///  solution of the Laplace equation with mixed boundary conditions by use of
///  BEM in 2D.
///
///  C++ adaptation for ANCSE17 of HILBERT V3.1 TUWien 2009-2013
///////////////////////////////////////////////////////////////////////////////
#ifndef _DOUBLELAYERPOTENTIAL_HPP_GUARD
#define _DOUBLELAYERPOTENTIAL_HPP_GUARD

#include "geometry.hpp"


/**
 *  Computes the double-layer potential type integral        
 *  \f[   G(k,p,q) = \int_{-1}^1 t^k/|tp+q|^2 dt   \f]                
 *                                 
 *  by use of its antiderivative.  
 *
 *  @param[in] k    Power of t 
 *  @param[in] p,q  2d-vectors generated by direction vectors of the panels Ei,Ej
 *  @return Result of the integral \f$ \int_{-1}^1 t^k/|tp+q|^2 dt \f$       
 */
double dlp(int k, const Eigen::Vector2d& p, const Eigen::Vector2d& q);


/**
 *  This function computes one entry of the matrix K. It decides whether semi 
 *  analytic or analytic computation should be chosen via the criterion:     
 *  \f[ dist(Ei, Ej) \eta >= \min(diam(Ei), diam(Ej)) \f]
 *
 *  FALSE resp. \f$\eta=0\f$: compute analytically 
 *
 *  TRUE: compute semi analytically  
 *
 *  It furthermore ensures that the outer interval Ei is smaller than the inner
 *  one Ej. If this is not the case computeKijSwappedSemianalytic() is called. 
 *
 *  \f[ I0 = const\int_{-1}^1\int_{-1}^1 f(s,t) dtds  \f]
 *  \f[ I1 = const\int_{-1}^1\int_{-1}^1 f(s,t)t dtds \f]
 *  with: \f$const = -\frac{1}{2\pi}\frac{|Ei|}{2}\frac{|Ej|}{2}\f$ and 
 *  \f$ f(s,t)=<su+tv+w,n>/|su+tv+w|^2 \f$ 
 *
 *  All types of computation use dlp() to compute \f$I0,I1\f$, which are computed
 *  in computeKijAnalytic() or computeKijSemianalytic() and assembled to one 
 *  Kij-Entry in computeK().                                                   
 *
 *  @param[out] I0,I1  Pointers to the 2 summands I0,I1 which are needed for 
 *                     assembling one K_ij-Entry                            
 *  @param[in] eta     Admissibility constant greater or equal to 0
 *  @param[in] a,b,c,d  2d vectors with the coordinates of these points
 */
void computeKij(double* I0, double* I1, double eta,
                const Eigen::Vector2d& a, const Eigen::Vector2d& b,
		const Eigen::Vector2d& c, const Eigen::Vector2d& d);


/**
 *  Analytic computation of K_ij by use of antiderivatives. I0 and I1 are solved
 *  with dlp(), whereas u=a-b, v=d-c and w=c+d-(a+b).
 *
 *  @param[out] I0,I1  Pointers to the 2 summands I0,I1 which are needed for 
 *                     assembling one K_ij-Entry    
 *  @param[in] a,b,c,d  2d vectors with the coordinates of these points   
 */
void computeKijAnalytic(double* I0, double* I1,
			const Eigen::Vector2d& a, const Eigen::Vector2d& b,
			const Eigen::Vector2d& c, const Eigen::Vector2d& d);


/**
 *  Computes the entry K_ij similar to computeKijAnalytic(), but the integration
 *  order is swapped, i.e. u=d-c, v=a-b and  w=c+d-(a+b).   
 *
 *  @param[out] I0,I1  Pointers to the 2 summands I0,I1 which are needed for 
 *                     assembling one K_ij-Entry    
 *  @param[in] a,b,c,d  2d vectors with the coordinates of these points 
*/
void computeKijSwappedAnalytic(double* I0, double* I1,
			       const Eigen::Vector2d& a,
			       const Eigen::Vector2d& b,
			       const Eigen::Vector2d& c,
			       const Eigen::Vector2d& d);


/**
 *  The entries of the K-matrix are calculated semi analytic. 
 *  The outer integration (Ei) is approximated with 16-point Gaussian quadrature 
 *  and the inner one (Ej) is computed analytically, i.e. u=a-b, v=d-c and 
 *   w=c+d-(a+b).                
 *
 *  @param[out] I0,I1  Pointers to the 2 summands I0,I1 which are needed for 
 *                     assembling one K_ij-Entry    
 *  @param[in] a,b,c,d  2d vectors with the coordinates of these points 
 */
void computeKijSemianalytic(double* I0, double* I1, 
			    const Eigen::Vector2d& a, const Eigen::Vector2d& b,
			    const Eigen::Vector2d& c, const Eigen::Vector2d& d);


/**
 *  Computes the K_ij-Entry similar to computeKijSemianalytic(), but the
 *  integration order is swapped,i.e. u=d-c, v=a-b and w=c+d-(a+b).        
 *
 *  @param[out] I0,I1  Pointers to the 2 summands I0,I1 which are needed for 
 *                     assembling one K_ij-Entry    
 *  @param[in] a,b,c,d  2d vectors with the coordinates of these points 
*/
void computeKijSwappedSemianalytic(double* I0, double* I1, 
				   const Eigen::Vector2d& a,
				   const Eigen::Vector2d& b,
				   const Eigen::Vector2d& c,
				   const Eigen::Vector2d& d);

#endif

